Below is a **production-ready, headless** architecture + implementation blueprint for a **ChatGPT Apps SDK / MCP-first fashion + styling product** where the only “UI” is a **Map widget inside ChatGPT** (plus conversational UX). I’ll go end-to-end: system design, data, AI, security, repo layout, core files, example tool contracts, widget behavior, and example user workflows.

---

## 0) Two hard realities you should design around

### Reality A: “Log into major fashion sites, store credentials, crawl, and purchase” is usually not viable

Most large retailers **do not** permit automated browsing/checkout via stored passwords, and 2FA/anti-bot protections will break “headless purchasing.” Even if it works briefly, it’s fragile and legally risky.

**Production-ready alternative:**

1. **Product discovery** via **official APIs**, **affiliate/product feeds**, or **partner aggregators**.
2. **Checkout** via:

   * **Deep links** to retailer checkout/cart (user completes purchase), OR
   * **Agentic Checkout / ACP** when merchants support it, OR
   * You become **merchant-of-record** (heavy: payments, tax, returns, fraud).

OpenAI’s commerce docs frame ACP as an “open standard” for agentic purchases inside ChatGPT. ([OpenAI Developers][1])

### Reality B: Multi-user “inside ChatGPT” requires proper OAuth

Anything user-specific (photos, address, orders) must be protected. Apps SDK expects OAuth 2.1 aligned to MCP auth requirements, including protected resource metadata and PKCE. ([OpenAI Developers][2])

---

## 1) What you’re building (in one sentence)

A **multi-tenant MCP server** that exposes **styling tools + a Map-based “Style Space” widget**; users set a monthly budget, upload photos, rate items/outfits, receive try-on previews, and approve purchases via a secure approval flow.

---

## 2) UX concept: “Style Space Map” (map UI without a traditional UI)

Instead of a geographic map of Earth, you create a **2D “style embedding space”**:

* Every product/outfit has an embedding (image+text).
* You reduce embeddings to 2D (UMAP/t-SNE) to get stable coordinates.
* The Map widget shows clusters (minimalist, streetwear, formal, etc.).
* Panning/zooming fetches more items in that region.
* Clicking a marker shows a “detail pane” (photos, price, sizes, rating buttons).
* Long-press / buttons: “Love / Like / Dislike”, “Try-on”, “Add to shortlist”, “Build outfit from this”.

OpenAI’s Apps SDK planning docs explicitly include a **Map component pattern** with clustering and detail panes, and recommend keeping the model in sync using `ui/update-model-context`. ([OpenAI Developers][3])
The official examples repo mentions a Pizzaz demo that includes **map view** + “shop/checkout” flows and demonstrates the `window.openai` surface (state, callTool, openExternal, follow-up messages). ([GitHub][4])

---

## 3) High-level architecture (production)

### 3.1 Public edge (what ChatGPT connects to)

**MCP Server (Streamable HTTP)**

* Endpoint: `POST /mcp` (and associated transport handling)
* Serves:

  * Tools (recommendations, ratings, try-on, checkout intents)
  * UI resources (the Map widget HTML/JS bundle via `ui://…`)
* Auth:

  * OAuth 2.1 resource server validation on each tool call

Streamable HTTP is the modern transport; the spec includes security warnings (notably validating `Origin` to prevent DNS rebinding). ([Model Context Protocol][5])

### 3.2 Internal services (you control)

* **Identity / Auth** (or Auth0/Okta/Cognito)
* **User Profile Service**

  * sizes, budget, preferences, constraints, saved addresses
  * photo consent + retention policies
* **Catalog Service**

  * normalized products/offers across sources
  * availability, price updates
* **Recommender Service**

  * embeddings, ranking, personalization, outfit assembly
* **Try-on Service**

  * virtual try-on generation (vendor API or your own model)
* **Commerce Orchestrator**

  * approval links, carts, order status, returns
* **Notifications**

  * email/SMS/webhook “Approve order” link, shipping updates
* **Observability**

  * tracing, metrics, audit logs (critical for commerce + privacy)

### 3.3 Data stores

* **Postgres** (source of truth)
* **Redis** (session/cache/rate limits)
* **Object storage** (S3/GCS) for user photos + generated try-on images
* **Vector store** (pgvector in Postgres or dedicated) for embeddings

---

## 4) Core workflows (what happens end-to-end)

### Workflow 1: First-time user onboarding (minimal steps)

1. User opens your ChatGPT app.
2. ChatGPT invokes a tool that requires auth → your server returns a `401` with `WWW-Authenticate` and resource metadata URL.
3. ChatGPT shows the OAuth linking UI; user logs in and consents.
4. User says:

   * “Monthly budget $250, I want 2 work outfits + 1 weekend outfit a week.”
5. Model calls:

   * `profile.upsertBudgetAndGoals`
6. Widget opens to the Style Space map with starter recommendations.
7. User uploads 3–5 photos (front, side, full body, good lighting).
8. Model calls:

   * `profile.ingestPhotos`
9. Try-on is now enabled.

OAuth requirements and how ChatGPT discovers `/.well-known/oauth-protected-resource`, uses PKCE, and expects `https://chatgpt.com/connector_platform_oauth_redirect` are described in the Apps SDK auth guide. ([OpenAI Developers][2])

### Workflow 2: Exploration + preference learning (ratings loop)

1. Map shows markers (products/outfits).
2. User taps items and hits Like/Dislike.
3. Widget calls `tools/call → feedback.rate`.
4. Server updates preference vector + logs event.
5. Server responds with refreshed nearby recommendations.

Apps SDK guidance: render from latest `structuredContent` from `ui/notifications/tool-result`; keep model in sync via `ui/update-model-context`; optionally store UI-only state with `window.openai.setWidgetState`. ([OpenAI Developers][3])

### Workflow 3: Outfit plan generation within monthly budget

1. User: “Build my March capsule with $300.”
2. Model calls `plan.generateCapsule`.
3. Server returns:

   * 12–18 items + 10 outfits (mix-and-match)
   * budget breakdown and alternatives
4. User clicks “Try-on outfit #3”
5. Model calls `tryon.renderOutfit` (async job)
6. When done, tool response returns image URLs; widget shows before/after

### Workflow 4: “Approve order” + purchase

1. User accepts items/outfits.
2. Model calls `checkout.createApprovalLink` with chosen SKUs/sizes/shipping address.
3. Server returns a signed URL (approval page) that:

   * shows full order summary
   * allows removing items / size changes
   * requires explicit user confirmation
4. After approval:

   * either deep-link user to retailer carts
   * or execute partner API checkout
   * or ACP/embedded checkout (only where supported)

OpenAI’s commerce docs describe ACP as a standard enabling agentic purchase flows. ([OpenAI Developers][1])

---

## 5) Tool design (MCP): what tools you need

You want **small, composable tools** (not one mega-tool). The Map UI updates best when tool responses are structured and incremental.

### Tool groups

**Profile**

* `profile.get`
* `profile.upsertBudgetAndGoals`
* `profile.upsertSizes`
* `profile.ingestPhotos`
* `profile.setAddress`
* `profile.deletePhotos` (compliance)

**Catalog**

* `catalog.search` (filters + budget + categories)
* `catalog.getItem`
* `catalog.getAvailability`

**Feedback**

* `feedback.rateItem`
* `feedback.rateOutfit`
* `feedback.undo`

**Map / Explore**

* `styleMap.getViewportItems` (given bounds/zoom)
* `styleMap.getClusters`
* `styleMap.getItemNeighbors`

**Planning**

* `plan.generateOutfits`
* `plan.generateCapsule`
* `plan.swapItemInOutfit`

**Try-on**

* `tryon.renderItemOnUser`
* `tryon.renderOutfitOnUser`
* `tryon.getJobStatus`

**Checkout / Orders**

* `checkout.createApprovalLink`
* `checkout.getApprovalStatus`
* `orders.place` (only after approval)
* `orders.status`
* `returns.initiate`

### Auth policy per tool

Apps SDK recommends declaring tool auth policy with `securitySchemes` (e.g., `noauth` vs `oauth2`) and still verifying tokens server-side. ([OpenAI Developers][2])

---

## 6) Repo layout (monorepo) and the exact files to build

Here’s a production-grade structure that keeps MCP edge concerns separate from internal services.

```text
fashion-mcp/
  apps/
    mcp-server/
      src/
        index.ts
        mcp/
          server.ts
          transport.ts
          resources.ts
          tools/
            profile.ts
            catalog.ts
            styleMap.ts
            feedback.ts
            planning.ts
            tryon.ts
            checkout.ts
            orders.ts
          auth/
            protectedResource.ts
            verifyAccessToken.ts
            scopes.ts
          middleware/
            originGuard.ts
            rateLimit.ts
            auditLog.ts
          db/
            pool.ts
            queries/
              catalog.sql.ts
              profile.sql.ts
            migrations/
        config.ts
      public/
        widget/
          style-map.html
          style-map.js        (bundled)
          style-map.css       (bundled)
      package.json
      tsconfig.json
      Dockerfile

  services/
    ingestion/
      src/
        feeds/
          partnerA.ts
          partnerB.ts
        normalize.ts
        scheduler.ts
      Dockerfile
    recommender/
      src/
        embed/
          imageEmbed.ts
          textEmbed.ts
        rank/
          rerank.ts
          bandit.ts
        outfit/
          assembler.ts
          constraints.ts
      Dockerfile
    tryon/
      src/
        provider/
          vendorX.ts
        pipeline.ts
      Dockerfile
    commerce/
      src/
        approvals.ts
        retailerLinks.ts
        partnerCheckout.ts
      Dockerfile

  packages/
    shared/
      src/
        types.ts
        zodSchemas.ts
        money.ts

  infra/
    terraform/
    k8s/
    monitoring/
      dashboards/
      alerts/

  docs/
    architecture.md
    tool-contracts.md
    privacy-and-data.md
    runbooks.md
```

---

## 7) MCP server: transport + resource + tools (core code)

### 7.1 Streamable HTTP transport (Express)

This is the minimum viable “production transport skeleton” (you’ll add auth, origin checks, rate limits, logging).

Koyeb’s tutorial shows a canonical Express + `StreamableHTTPServerTransport` setup and explicitly notes stateless configuration by setting `sessionIdGenerator: undefined`. ([Koyeb][6])

```ts
// apps/mcp-server/src/mcp/transport.ts
import express, { Request, Response } from "express";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";

export function createHttpApp(server: McpServer) {
  const app = express();
  app.use(express.json({ limit: "2mb" }));

  const transport = new StreamableHTTPServerTransport({
    sessionIdGenerator: undefined, // stateless (scale horizontally)
  });

  // Connect server <-> transport once at boot
  async function setup() {
    await server.connect(transport);
  }

  app.post("/mcp", async (req: Request, res: Response) => {
    try {
      await transport.handleRequest(req, res, req.body);
    } catch (err) {
      if (!res.headersSent) {
        res.status(500).json({
          jsonrpc: "2.0",
          error: { code: -32603, message: "Internal server error" },
          id: null,
        });
      }
    }
  });

  app.get("/mcp", (_req, res) => res.status(405).json({
    jsonrpc: "2.0",
    error: { code: -32000, message: "Method not allowed." },
    id: null,
  }));

  return { app, setup };
}
```

### 7.2 Origin guard (required for production)

The MCP transport spec explicitly warns servers **MUST validate `Origin`** to prevent DNS rebinding. ([Model Context Protocol][5])

```ts
// apps/mcp-server/src/middleware/originGuard.ts
import type { Request, Response, NextFunction } from "express";

const ALLOWED_ORIGINS = new Set([
  "https://chatgpt.com",
  "https://www.chatgpt.com",
  // add any Apps SDK host origins you support
]);

export function originGuard(req: Request, res: Response, next: NextFunction) {
  const origin = req.headers.origin;
  if (!origin) return next(); // some server-to-server calls may omit
  if (!ALLOWED_ORIGINS.has(origin)) {
    return res.status(403).json({ error: "forbidden_origin" });
  }
  next();
}
```

### 7.3 OAuth protected resource metadata endpoint

Apps SDK auth guide: you must host
`GET https://your-mcp.example.com/.well-known/oauth-protected-resource` and return a JSON document with `resource`, `authorization_servers`, etc. ([OpenAI Developers][2])

```ts
// apps/mcp-server/src/auth/protectedResource.ts
import type { Request, Response } from "express";

export function oauthProtectedResource(req: Request, res: Response) {
  res.json({
    resource: "https://api.yourdomain.com", // canonical identifier
    authorization_servers: ["https://auth.yourdomain.com"],
    scopes_supported: [
      "profile:read",
      "profile:write",
      "photos:write",
      "orders:write",
    ],
    resource_documentation: "https://yourdomain.com/docs/mcp",
  });
}
```

### 7.4 Token verification (resource server responsibilities)

Apps SDK auth guide spells out: verify signature, issuer, audience/resource, expiry, scopes; do not trust tokens implicitly. ([OpenAI Developers][2])

Implementation detail: use JWKS (`jose` in Node) and enforce `aud` = your MCP resource.

---

## 8) UI resource: the Map widget (served into ChatGPT)

### 8.1 How the widget receives tool output

MCP Apps bridge: tool results come through `window.openai.toolOutput`, and you can also listen for message events like `ui/notifications/tool-result`. ([OpenAI Developers][7])

### 8.2 Widget file

```html
<!-- apps/mcp-server/public/widget/style-map.html -->
<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="color-scheme" content="light dark" />
    <link rel="stylesheet" href="/widget/style-map.css" />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/widget/style-map.js"></script>
  </body>
</html>
```

### 8.3 Widget JS responsibilities (must-have behaviors)

Your widget should:

* Render from the **latest tool output**.
* On pan/zoom:

  * call `tools/call` (`window.openai.callTool`) to fetch viewport items
* On click marker:

  * show details + actions
* On action:

  * rate item/outfit
  * request try-on
  * open external product link (`openExternal`)
* Keep model in sync:

  * call `ui/update-model-context` for model-visible state (selected item, filters)
  * optionally store ephemeral UI state with `setWidgetState`

OpenAI’s design guide explicitly recommends using `ui/update-model-context` for model-visible UI state and `setWidgetState` for UI-only persistence. ([OpenAI Developers][3])

---

## 9) The “style map” data contract (what tool returns)

### Tool: `styleMap.getViewportItems`

**Input**

```json
{
  "viewport": { "xmin": 0.12, "xmax": 0.34, "ymin": 0.55, "ymax": 0.88 },
  "zoom": 4,
  "filters": { "category": ["tops","pants"], "maxPrice": 120 },
  "limit": 120
}
```

**Output (structuredContent)**

```json
{
  "type": "style_map",
  "viewport": { "xmin": 0.12, "xmax": 0.34, "ymin": 0.55, "ymax": 0.88 },
  "items": [
    {
      "id": "prod_123",
      "x": 0.21,
      "y": 0.73,
      "kind": "product",
      "title": "Relaxed Oxford Shirt",
      "brand": "BrandA",
      "price": { "amount": 58, "currency": "USD" },
      "imageUrl": "https://cdn…/prod_123.jpg",
      "sizes": ["S","M","L"],
      "retailerUrl": "https://retailer…",
      "score": 0.82
    }
  ],
  "clusters": [
    { "id": "c1", "x": 0.24, "y": 0.77, "count": 34, "label": "Minimal / Workwear" }
  ]
}
```

**Tool response metadata**
Return `_meta.openai/outputTemplate = "ui://widget/style-map.html"` so ChatGPT renders your map widget for this tool. The Apps SDK examples and docs emphasize that tools can return structured payloads plus widget templates. ([GitHub][4])

---

## 10) AI/ML system (what “a lot of AI” really means here)

### 10.1 Product understanding

* **Image embeddings** (CLIP-like) from product photos
* **Text embeddings** from title/description
* **Attribute extraction**

  * category, material, season, formality, color palette
* **Deduping**

  * perceptual hashing + embedding similarity to collapse duplicates across sellers

### 10.2 Personalization engine (ratings → preference vector)

* Maintain user vector `u` in same embedding space
* Each Like/Dislike updates `u` (online learning)
* Rank candidate items by:

  * similarity(u, item)
  * constraints: sizes in stock, shipping region, budget, brand blocks, etc.
* Add exploration:

  * multi-armed bandit so recommendations don’t stagnate

### 10.3 Outfit assembly (constraint optimization)

Build outfits as a constrained search:

* Must cover required slots (top, bottom, shoes, outerwear, accessory)
* Compatibility scoring (color harmony, formality match)
* Budget constraint: monthly cap + per-outfit cap
* Diversity constraint: avoid 10 black tees

### 10.4 Virtual try-on

Production approach:

* Use a **specialized try-on vendor** initially (SLA, quality, speed)
* Later: own pipeline (human parsing, pose, garment warping, diffusion)
  Key: store **only what you need**, encrypt at rest, and provide deletion.

---

## 11) Commerce: approval + ordering patterns (production-safe)

### Pattern 1 (recommended): Approval link → retailer cart deep link

* Your system creates a **session** containing items, sizes, shipping estimates.
* User clicks approve → you generate retailer cart links (or per-item links).
* User checks out on retailer site.
  Pros: easiest compliance, no handling payment.
  Cons: user must complete checkout.

### Pattern 2: Partner checkout APIs

Some partners let you create cart + checkout via API after user approval.

### Pattern 3: Embedded checkout (ACP)

Where merchants support ACP/agentic checkout, you can do embedded flows inside ChatGPT. ([OpenAI Developers][1])

---

## 12) Example “production-grade” operational requirements (don’t skip)

### Security & privacy

* OAuth 2.1 PKCE + dynamic client registration requirements (ChatGPT expects it). ([OpenAI Developers][2])
* Enforce:

  * token signature/issuer/audience/scope checks ([OpenAI Developers][2])
  * Origin allowlist for MCP endpoint ([Model Context Protocol][5])
* Encrypt:

  * photos and try-on renders (KMS)
  * PII fields (address)
* Audit logs:

  * who requested try-on
  * who created approval link
  * who placed order

### Reliability

* Latency targets:

  * map viewport fetch < 400ms cached
* Async jobs:

  * try-on generation via queue with status polling tool

### Observability

* Correlate:

  * tool call ID ↔ widget telemetry ↔ backend traces
    Apps SDK planning docs recommend planning telemetry early for inline experiences. ([OpenAI Developers][3])

---

## 13) Concrete example: end-to-end user session (with tool calls)

### User

> “I have $250/month. Style me for work + weekends. I like minimalist / Scandinavian.”

### Model calls

1. `profile.upsertBudgetAndGoals({budget:250, goals:["work","weekend"], styleTags:["minimal","scandi"]})`

2. `styleMap.getViewportItems({viewport: default, zoom: 2, filters:{maxPrice:120}})`
   → Widget opens, shows clustered items

### User taps 6 items and hits Like/Dislike

Widget calls:

* `feedback.rateItem({itemId:"prod_123", rating:+1})`
* `feedback.rateItem({itemId:"prod_555", rating:-1})`

### User

> “Build me 8 outfits under my budget.”

Model calls:

* `plan.generateCapsule({month:"2026-03", budget:250, outfitCount:8})`

### User

> “Try outfit #2 on me.”

Model calls:

* `tryon.renderOutfitOnUser({outfitId:"outfit_2", photoSetId:"photoset_9"})`

### User

> “Order the items for outfits 2 and 4. Ship to my home address.”

Model calls:

* `checkout.createApprovalLink({outfitIds:["outfit_2","outfit_4"], addressId:"addr_default"})`

User clicks approve link → approval status webhook → model can call:

* `orders.place({approvalId:"appr_77"})` (only if you’re actually executing checkout)

---

## 14) What you should build first (even “not MVP” needs sequencing)

Even if you’re not calling it an MVP, production products still need a safe ramp:

1. **Auth + multi-tenancy + data model** (no compromises)
2. **Catalog ingestion from 1–2 legitimate sources**
3. **Map “style space” exploration + rating loop**
4. **Outfit generation**
5. **Try-on** (vendor) + privacy controls
6. **Approval flow**
7. **Commerce integration expansion**

---

## 15) If you want, I can generate the starter repo code skeleton

If you tell me your preferred stack (Node/TS vs Python) and cloud (AWS/GCP), I can output:

* the exact `package.json`, Dockerfiles, env vars
* a working MCP server with:

  * OAuth metadata endpoint
  * one authenticated tool
  * one map widget resource
  * one styleMap tool returning dummy data
* plus the DB schema (Postgres + pgvector)

But the blueprint above already matches how Apps SDK + MCP expects production servers to behave (auth, tool/widget contracts, state sync, transport). ([OpenAI Developers][2])

[1]: https://developers.openai.com/commerce/ "https://developers.openai.com/commerce/"
[2]: https://developers.openai.com/apps-sdk/build/auth/ "https://developers.openai.com/apps-sdk/build/auth/"
[3]: https://developers.openai.com/apps-sdk/plan/components/ "https://developers.openai.com/apps-sdk/plan/components/"
[4]: https://github.com/openai/openai-apps-sdk-examples "https://github.com/openai/openai-apps-sdk-examples"
[5]: https://modelcontextprotocol.io/specification/2025-03-26/basic/transports "https://modelcontextprotocol.io/specification/2025-03-26/basic/transports"
[6]: https://www.koyeb.com/tutorials/deploy-remote-mcp-servers-to-koyeb-using-streamable-http-transport "https://www.koyeb.com/tutorials/deploy-remote-mcp-servers-to-koyeb-using-streamable-http-transport"
[7]: https://developers.openai.com/apps-sdk/build/chatgpt-ui/ "Build your ChatGPT UI"


[Download the starter repo (zip)](sandbox:/mnt/data/fashion-mcp-starter.zip)

This zip gives you a **working, end-to-end “headless” foundation**: an **MCP server (Streamable HTTP)** + a **Map widget** (single-file HTML) that runs inside ChatGPT via the **MCP Apps bridge** (JSON-RPC over `postMessage`). It’s structured as a production-grade scaffold (auth, DB schema, resource registration, tool contracts), while leaving the truly large pieces (real catalog ingestion, embeddings, try-on pipeline, checkout integrations) as clearly-defined modules to implement next.

The design and code align with:

* Apps SDK requiring an MCP server (+ optional iframe UI resource). ([OpenAI Developers][1])
* UI bridge patterns (`ui/initialize`, `tools/call`, `ui/notifications/tool-result`, `ui/update-model-context`). ([OpenAI Developers][2])
* OAuth protected resource discovery + `WWW-Authenticate` challenge guidance. ([OpenAI Developers][3])
* Streamable HTTP security requirement to validate `Origin` header. ([Model Context Protocol][4])

---

## What you get in the repo

### Runs today (local)

* `styleMap.getViewportItems` tool returns structured data for the map.
* Map widget lets the user pan/zoom/click items and call tools from the UI (`feedback.rateItem`, `checkout.createApprovalLink`).
* Postgres schema + seed demo products.
* An “approval link” page (minimal external page for explicit order consent).

### The “production-ready” scaffolding parts included

* **Stateless server** patterns (horizontally scalable) with Streamable HTTP.
* **OAuth discovery endpoint** (`/.well-known/oauth-protected-resource`) and correct 401 challenge header shape for ChatGPT auth discovery. ([OpenAI Developers][3])
* **Origin allowlist guard** for DNS rebinding mitigation. ([Model Context Protocol][4])
* **Per-request auth context** via `AsyncLocalStorage` so tool handlers reliably know **which user** they’re operating on (critical for multi-user).

---

## Quick local run

Inside the zip’s `README.md` you’ll see:

* `docker compose up -d` (Postgres + Redis)
* `npm install`
* `npm run db:migrate`
* `npm run db:seed`
* `npm run dev`

Then MCP endpoint is:

* `http://localhost:8787/mcp`

> Auth in dev: include header `Authorization: Bearer dev_user_123`
> (So you can test multi-user by changing the suffix.)

---

## File-by-file: what matters and why

### Root

* `docker-compose.yml`
  Brings up Postgres + Redis (Redis not used yet in the starter, but it’s part of the production shape: rate limits, queues, caching).
* `docs/production-checklist.md`
  Non-negotiables: privacy, auth, consent, commerce safety.

### `apps/mcp-server/src/index.ts`

* Creates the Express server
* Adds `originGuard`
* Serves:

  * `/.well-known/oauth-protected-resource` (OAuth discovery)
  * `/mcp` (MCP JSON-RPC endpoint)
  * `/approve/:token` (approval flow page)

### `apps/mcp-server/src/mcp/transport.ts`

* Implements Streamable HTTP transport with:

  * stateless `sessionIdGenerator: undefined`
  * **auth verification** on every POST
  * `WWW-Authenticate` challenge when missing token (the key piece for ChatGPT OAuth bootstrapping) ([OpenAI Developers][3])
  * `runWithAuth()` wrapping `transport.handleRequest(...)` so tool handlers can read user identity reliably.

### `apps/mcp-server/src/mcp/server.ts`

This is the heart:

* Registers the widget as an MCP Apps **resource**:

  * URI: `ui://widget/style-map.html`
* Registers tools with `registerAppTool(...)`
* Tools included:

  * `profile.get`
  * `profile.upsertBudgetAndGoals`
  * `styleMap.getViewportItems`  ✅ map data
  * `feedback.rateItem` ✅ personalization signal
  * `plan.generateCapsule` ✅ demo capsule plan
  * `checkout.createApprovalLink` ✅ consent link
  * `orders.getApprovalStatus`

When tools want to open the map in ChatGPT, they include `_meta.ui.resourceUri = "ui://widget/style-map.html"` (same concept as the Apps SDK quickstart pattern). ([OpenAI Developers][1])

### `apps/mcp-server/public/style-map.html`

A single-file widget that:

* Initializes the MCP Apps bridge (`ui/initialize`) and listens for `ui/notifications/tool-result`. ([OpenAI Developers][2])
* Calls tools from the UI using `tools/call`. ([OpenAI Developers][2])
* Implements:

  * pan/zoom
  * dot selection
  * like/dislike (calls `feedback.rateItem`)
  * “Create approval link” demo button

---

## How the “Map-only UX” works end-to-end

### The core loop (what users feel)

1. User says: “Budget is $250/month, show me smart casual.”
2. Model calls:

   * `profile.upsertBudgetAndGoals({ monthlyBudget: 250, styleTags: ["smart casual"] })`
3. Model calls:

   * `styleMap.getViewportItems({ viewport: ..., zoom: ..., filters: ... })`
4. ChatGPT renders the widget because the tool response includes `_meta.ui.resourceUri` and `structuredContent.type="style_map"`. ([OpenAI Developers][1])
5. User navigates the map:

   * clicks dots → sees item details
   * likes/dislikes → widget calls `feedback.rateItem`
6. The model (or widget) refreshes viewport results → recommendations shift based on feedback signals.

That’s the “no UI, only map” experience.

---

## Example workflows (detailed)

### Workflow A — Onboarding → Map exploration → Capsule plan

**User:** “I have $300/mo. I want minimal, monochrome outfits for work.”

**Model tool calls**

1. `profile.upsertBudgetAndGoals`

* stores budget + tags

2. `styleMap.getViewportItems`

* widget appears
* user likes ~10 items, dislikes ~5 items

3. `plan.generateCapsule({ month: "2026-03", outfitCount: 10 })`

* returns:

  * selected items
  * outfits
  * budget breakdown

**User:** “Swap to more formal shoes.”

* model calls `styleMap.getViewportItems` with filters `category=["shoes"]` and refined viewport near the liked region.

---

### Workflow B — Event styling (wedding) with constraints

**User:** “I have a wedding in April. Dress code: semi-formal. Budget $400 for one outfit.”

**Model**

1. Updates profile tags + goal:

   * `profile.upsertBudgetAndGoals({ monthlyBudget: ..., goals: ["wedding April semi-formal"], styleTags:[...] })`

2. Map opens to semi-formal cluster:

   * `styleMap.getViewportItems(filters: { maxPrice: 400 })`

**User uses map**

* likes 2–3 candidate looks

**Model**

* builds a single outfit plan (in full product: `outfits.generate`)
* then:

3. `checkout.createApprovalLink({ itemIds: [...] })`

* returns a link for explicit approval (and optional address verification in that flow)

---

### Workflow C — Approval → Order placement (production design)

**User:** “Yes, order it.”

**System requirement**

* even if user says “yes” in chat, you still want a **recorded consent artifact**:

  * approval link click
  * “approve” button
  * timestamp
  * exact items, prices, shipping

**Model**

* calls:

  * `orders.getApprovalStatus({ token })`
* if `approved`, then (in the full product) you would call:

  * `orders.placeApprovedOrder({ token })`

> The starter includes approval creation + status checking; “place order” is intentionally not implemented until you integrate official commerce flows.

---

## Comprehensive use cases your full product should support

Below is a detailed “product-complete” capability list (not MVP). If you implement these, you’ll have the full system you described.

### 1) Account + identity (multi-user, real production)

* Create account via OAuth (ChatGPT as client, your auth server as issuer)
* Household accounts (multiple people under one payer)
* Multi-profile switching entirely through MCP (no traditional UI):

  * “Switch to styling my partner”
  * “Create a profile for my child”

### 2) Personal profile capture (zero-friction UX)

* Budget:

  * monthly budget
  * one-off budgets (event purchase)
  * category budgets (shoes vs basics)
* Fit & constraints:

  * sizes (tops/bottoms/shoes)
  * fit preferences (oversized/slim)
  * comfort constraints (no wool, no heels)
* Style:

  * tags (“minimal”, “streetwear”, “classic”)
  * style goals (“look taller”, “broader shoulders”, “hide midsection”)
* Climate + lifestyle:

  * city, commute type, office dress code
  * travel schedule

### 3) Photo onboarding + consent (critical for try-on)

* Upload photos inside ChatGPT widget (when host supports it) ([OpenAI Developers][2])
* Explicit consent prompts:

  * “Use my photos for virtual try-on”
  * “Store photos for future sessions”
* Photo set management:

  * add/remove photos
  * re-run body/pose estimation when new photos uploaded

### 4) Style Map exploration (the primary UX)

* Map-based browsing:

  * 2D “style space” (clusters like “minimal”, “workwear”, “streetwear”, etc.)
  * zoomed-out clusters → zoomed-in individual products
* Filters:

  * category, price, color palette, brand
  * ethical flags (cruelty-free, sustainable)
  * shipping speed and return policy
* Actions on map pins:

  * like/dislike
  * “show similar”
  * “build outfit around this”
  * “add to capsule”

### 5) Outfit generation + capsule wardrobes

* Capsule plan by:

  * month/season
  * events (weddings, interviews)
  * travel packing list
* Constraints:

  * budget cap
  * “at least N outfits”
  * “reuse items I already own”
* Explainability:

  * why an item is chosen (coverage gaps, versatility)

### 6) Virtual try-on (production-grade)

* Single item try-on
* Full outfit try-on
* Multiple angles / lighting normalization
* Quality control:

  * reject low-quality outputs
  * show confidence score
  * always provide fallback (flat-lay + fit explanation)

### 7) Commerce and ordering (safe + compliant)

* Never store retailer passwords
* Prefer:

  * official retailer APIs
  * affiliate feeds + deep links
  * “checkout handoff” (user completes checkout)
* If you do “order for user”:

  * require explicit consent via approval link
  * payment handled by PCI-compliant provider
  * full audit logs

### 8) Post-purchase lifecycle

* Track shipments
* Out-of-stock substitutions:

  * propose alternatives on the map in the same style neighborhood
* Returns/exchanges assistant:

  * size exchange suggestions
  * return window reminders

### 9) Ongoing personalization (“AI stylist” that improves)

* Learn from:

  * likes/dislikes
  * purchases
  * returns (strong negative signal)
  * time-to-wear or “kept vs returned”
* Personalization guardrails:

  * avoid overfitting to one category
  * enforce diversity (colors, silhouettes)

### 10) Admin / operations (production reality)

* Partner management:

  * feed health dashboards
  * pricing anomalies
  * availability monitoring
* Safety:

  * prompt injection monitoring (tool call validation)
  * try-on abuse detection
* Model evaluation:

  * offline test sets
  * “outfit coherence” scoring
  * regression tests before deployments

---

## What you should implement next (to reach the *full* system you described)

The starter is your stable base. To reach full production:

1. **Catalog ingestion service**

* Partner feeds/APIs → canonical schema → index
* Add embeddings + 2D projection to power the map meaningfully

2. **Personalization**

* User preference vector store
* Ranking with diversity + budget constraints

3. **Try-on pipeline**

* Async job queue
* Storage + signed URLs
* Strong privacy controls

4. **Commerce integration**

* approval → verified consent → partner checkout
* returns/exchanges + tracking

---

If you want, I can also generate (in the same repo structure) the next layer of code for:

* a real **event-driven ingestion pipeline** (queue + workers),
* a **vector + UMAP map builder** job,
* and a **try-on job orchestration API** (status polling + signed URLs),

while keeping the UX strictly “map + chat”.

[1]: https://developers.openai.com/apps-sdk/quickstart/ "Quickstart"
[2]: https://developers.openai.com/apps-sdk/build/chatgpt-ui/ "Build your ChatGPT UI"
[3]: https://developers.openai.com/apps-sdk/build/auth/ "Authentication"
[4]: https://modelcontextprotocol.io/specification/2025-03-26/basic/transports?utm_source=chatgpt.com "Transports"
