<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Style Map</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      }
      html, body { margin: 0; padding: 0; width: 100%; height: 100%; }
      #app { display: flex; flex-direction: column; height: 100%; }
      #toolbar {
        display: flex;
        gap: 8px;
        align-items: center;
        padding: 10px 12px;
        border-bottom: 1px solid rgba(0,0,0,0.1);
      }
      #toolbar input, #toolbar select {
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid rgba(0,0,0,0.25);
      }
      #content { display: grid; grid-template-columns: 1fr 340px; min-height: 0; flex: 1; }
      #mapWrap { position: relative; overflow: hidden; }
      #map { width: 100%; height: 100%; background: radial-gradient(circle at 30% 20%, rgba(0,0,0,0.05), transparent 60%); cursor: grab; }
      #map:active { cursor: grabbing; }
      #detail {
        border-left: 1px solid rgba(0,0,0,0.1);
        padding: 12px;
        overflow: auto;
      }
      .card { border: 1px solid rgba(0,0,0,0.12); border-radius: 14px; padding: 10px; margin-bottom: 10px; }
      .row { display: flex; gap: 10px; align-items: center; }
      img { width: 72px; height: 72px; border-radius: 12px; object-fit: cover; }
      button {
        padding: 8px 10px;
        border-radius: 12px;
        border: 1px solid rgba(0,0,0,0.25);
        background: transparent;
        cursor: pointer;
      }
      button.primary { border-color: rgba(0,0,0,0.6); }
      .muted { color: rgba(0,0,0,0.6); font-size: 12px; }
      .pill {
        display:inline-block;
        padding: 4px 8px;
        border: 1px solid rgba(0,0,0,0.2);
        border-radius: 999px;
        font-size: 12px;
        margin-right: 6px;
        margin-top: 6px;
      }
      .hint { position:absolute; left:10px; bottom:10px; font-size: 12px; background: rgba(255,255,255,0.8); padding: 6px 8px; border-radius: 10px; border: 1px solid rgba(0,0,0,0.12); }
    </style>
  </head>
  <body>
    <div id="app">
      <div id="toolbar">
        <b>Style Space</b>
        <span class="muted">pan/zoom ‚Ä¢ click items ‚Ä¢ rate</span>
        <div style="flex:1"></div>
        <select id="category">
          <option value="">All categories</option>
          <option value="tops">Tops</option>
          <option value="bottoms">Bottoms</option>
          <option value="outerwear">Outerwear</option>
          <option value="shoes">Shoes</option>
        </select>
        <input id="maxPrice" type="number" min="0" step="1" placeholder="Max $" style="width: 110px;" />
        <button id="refresh" class="primary">Refresh</button>
      </div>

      <div id="content">
        <div id="mapWrap">
          <canvas id="map"></canvas>
          <div class="hint">Tip: zoom to see clusters ‚Ä¢ click dots for details</div>
        </div>
        <div id="detail">
          <div class="card">
            <div><b>Details</b></div>
            <div class="muted">Click an item on the map.</div>
          </div>
          <div class="card">
            <div><b>Actions</b></div>
            <button id="uploadPhotos">Upload my photos</button>
            <div class="muted" style="margin-top:6px;">
              Photo upload uses <code>window.openai.uploadFile</code> when available (ChatGPT extension).
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // --------------------------------------------
      // MCP Apps Bridge (JSON-RPC over postMessage)
      // Compatible with ChatGPT and other MCP Apps hosts.
      // --------------------------------------------
      let rpcId = 0;
      const pending = new Map();

      function rpcRequest(method, params) {
        return new Promise((resolve, reject) => {
          const id = ++rpcId;
          pending.set(id, { resolve, reject });
          window.parent.postMessage({ jsonrpc: "2.0", id, method, params }, "*");
        });
      }

      function rpcNotify(method, params) {
        window.parent.postMessage({ jsonrpc: "2.0", method, params }, "*");
      }

      window.addEventListener("message", (event) => {
        if (event.source !== window.parent) return;
        const msg = event.data;
        if (!msg || msg.jsonrpc !== "2.0") return;

        // response
        if (typeof msg.id === "number") {
          const p = pending.get(msg.id);
          if (!p) return;
          pending.delete(msg.id);
          if (msg.error) p.reject(msg.error);
          else p.resolve(msg.result);
          return;
        }

        // notifications
        if (msg.method === "ui/notifications/tool-result") {
          const data = msg.params?.structuredContent;
          if (data && data.type === "style_map") {
            state.lastMapPayload = data;
            render();
          }
        }
      }, { passive: true });

      async function initializeBridge() {
        // Matches Apps SDK quickstart structure.
        const appInfo = { name: "style-map", version: "0.1.0" };
        const appCapabilities = {};
        const protocolVersion = "2026-01-26";
        await rpcRequest("ui/initialize", { appInfo, appCapabilities, protocolVersion });
        rpcNotify("ui/notifications/initialized", {});
      }

      const bridgeReady = initializeBridge().catch((err) => {
        console.error("Bridge init failed", err);
      });

      // --------------------------------------------
      // Map state + rendering
      // --------------------------------------------
      const canvas = document.getElementById("map");
      const ctx = canvas.getContext("2d");
      const mapWrap = document.getElementById("mapWrap");

      const state = {
        viewport: { xmin: 0.0, xmax: 1.0, ymin: 0.0, ymax: 1.0 },
        zoom: 2,
        dragging: false,
        dragStart: null,
        lastMapPayload: null,
        selectedItemId: null
      };

      function resize() {
        const rect = mapWrap.getBoundingClientRect();
        canvas.width = Math.floor(rect.width * devicePixelRatio);
        canvas.height = Math.floor(rect.height * devicePixelRatio);
        canvas.style.width = rect.width + "px";
        canvas.style.height = rect.height + "px";
        render();
      }
      window.addEventListener("resize", resize, { passive: true });
      resize();

      function worldToScreen(x, y) {
        const vp = state.viewport;
        const sx = (x - vp.xmin) / (vp.xmax - vp.xmin) * canvas.width;
        const sy = (1 - (y - vp.ymin) / (vp.ymax - vp.ymin)) * canvas.height;
        return { sx, sy };
      }

      function screenToWorld(sx, sy) {
        const vp = state.viewport;
        const x = vp.xmin + (sx / canvas.width) * (vp.xmax - vp.xmin);
        const y = vp.ymin + ((canvas.height - sy) / canvas.height) * (vp.ymax - vp.ymin);
        return { x, y };
      }

      function drawText(label, x, y) {
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,0.65)";
        ctx.font = `${12 * devicePixelRatio}px system-ui`;
        ctx.fillText(label, x, y);
        ctx.restore();
      }

      function render() {
        ctx.clearRect(0,0,canvas.width,canvas.height);

        // Frame
        ctx.save();
        ctx.strokeStyle = "rgba(0,0,0,0.15)";
        ctx.lineWidth = 1 * devicePixelRatio;
        ctx.strokeRect(8*devicePixelRatio, 8*devicePixelRatio, canvas.width-16*devicePixelRatio, canvas.height-16*devicePixelRatio);
        ctx.restore();

        const payload = state.lastMapPayload;
        if (!payload) {
          drawText("No data yet. Click Refresh.", 16*devicePixelRatio, 28*devicePixelRatio);
          return;
        }

        // clusters
        for (const c of (payload.clusters || [])) {
          const p = worldToScreen(c.x, c.y);
          ctx.save();
          ctx.fillStyle = "rgba(0,0,0,0.08)";
          const r = Math.max(10, Math.sqrt(c.count) * 6) * devicePixelRatio;
          ctx.beginPath();
          ctx.arc(p.sx, p.sy, r, 0, Math.PI*2);
          ctx.fill();
          ctx.restore();
          drawText(`${c.label} (${c.count})`, p.sx + 8*devicePixelRatio, p.sy - 8*devicePixelRatio);
        }

        // items
        for (const it of (payload.items || [])) {
          const p = worldToScreen(it.x, it.y);
          const selected = it.id === state.selectedItemId;

          ctx.save();
          ctx.fillStyle = selected ? "rgba(0,0,0,0.9)" : "rgba(0,0,0,0.6)";
          const r = (selected ? 6 : 4) * devicePixelRatio;
          ctx.beginPath();
          ctx.arc(p.sx, p.sy, r, 0, Math.PI*2);
          ctx.fill();
          ctx.restore();
        }
      }

      // hit test near mouse
      function pickItemAt(sx, sy) {
        const payload = state.lastMapPayload;
        if (!payload) return null;
        let best = null;
        let bestD = Infinity;
        for (const it of (payload.items || [])) {
          const p = worldToScreen(it.x, it.y);
          const d = Math.hypot(p.sx - sx, p.sy - sy);
          if (d < bestD) { bestD = d; best = it; }
        }
        return bestD < 14 * devicePixelRatio ? best : null;
      }

      // --------------------------------------------
      // Tool calls (from UI)
      // --------------------------------------------
      async function callTool(name, args) {
        // If ChatGPT provides window.openai, you can use it. Otherwise use tools/call.
        if (window.openai && typeof window.openai.callTool === "function") {
          return await window.openai.callTool({ name, arguments: args });
        }
        await bridgeReady;
        return await rpcRequest("tools/call", { name, arguments: args });
      }

      async function refresh() {
        const cat = document.getElementById("category").value;
        const maxPrice = Number(document.getElementById("maxPrice").value || 0);
        const filters = {};
        if (cat) filters.category = [cat];
        if (maxPrice > 0) filters.maxPrice = maxPrice;

        const resp = await callTool("styleMap.getViewportItems", {
          viewport: state.viewport,
          zoom: state.zoom,
          filters,
          limit: 200
        });

        // tool result can be returned directly (if UI called tool), or via tool-result notification (if model called).
        const structured = resp?.structuredContent || resp?.result?.structuredContent;
        if (structured && structured.type === "style_map") {
          state.lastMapPayload = structured;
          render();
        }
      }

      document.getElementById("refresh").addEventListener("click", () => refresh());

      // --------------------------------------------
      // Pan / zoom interactions
      // --------------------------------------------
      canvas.addEventListener("mousedown", (e) => {
        state.dragging = true;
        state.dragStart = { x: e.offsetX * devicePixelRatio, y: e.offsetY * devicePixelRatio, vp: { ...state.viewport } };
      });

      window.addEventListener("mouseup", () => {
        if (!state.dragging) return;
        state.dragging = false;
        state.dragStart = null;
        refresh();
      });

      window.addEventListener("mousemove", (e) => {
        if (!state.dragging || !state.dragStart) return;
        const rect = canvas.getBoundingClientRect();
        const sx = (e.clientX - rect.left) * devicePixelRatio;
        const sy = (e.clientY - rect.top) * devicePixelRatio;

        const dx = sx - state.dragStart.x;
        const dy = sy - state.dragStart.y;

        const vp0 = state.dragStart.vp;
        const w = vp0.xmax - vp0.xmin;
        const h = vp0.ymax - vp0.ymin;

        // screen delta -> world delta
        const wx = -dx / canvas.width * w;
        const wy = dy / canvas.height * h;

        state.viewport = {
          xmin: vp0.xmin + wx,
          xmax: vp0.xmax + wx,
          ymin: vp0.ymin + wy,
          ymax: vp0.ymax + wy
        };
        render();
      }, { passive: true });

      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 1.12 : 0.89;
        const rect = canvas.getBoundingClientRect();
        const sx = (e.clientX - rect.left) * devicePixelRatio;
        const sy = (e.clientY - rect.top) * devicePixelRatio;
        const anchor = screenToWorld(sx, sy);

        const vp = state.viewport;
        const w = (vp.xmax - vp.xmin) * factor;
        const h = (vp.ymax - vp.ymin) * factor;

        // keep anchor stable
        const ax = (anchor.x - vp.xmin) / (vp.xmax - vp.xmin);
        const ay = (anchor.y - vp.ymin) / (vp.ymax - vp.ymin);

        const xmin = anchor.x - ax * w;
        const xmax = xmin + w;
        const ymin = anchor.y - ay * h;
        const ymax = ymin + h;

        state.viewport = { xmin, xmax, ymin, ymax };
        state.zoom = Math.max(0, Math.min(20, state.zoom + (e.deltaY > 0 ? -1 : 1)));
        render();

        // throttle refresh slightly
        clearTimeout(window.__wheelTimer);
        window.__wheelTimer = setTimeout(() => refresh(), 120);
      }, { passive: false });

      // click: select item + show details
      canvas.addEventListener("click", async (e) => {
        const sx = e.offsetX * devicePixelRatio;
        const sy = e.offsetY * devicePixelRatio;
        const it = pickItemAt(sx, sy);
        if (!it) return;

        state.selectedItemId = it.id;
        render();
        showDetails(it);

        // Keep model-visible context in sync (if the host supports it).
        try {
          await rpcRequest("ui/update-model-context", {
            content: [{ type: "text", text: `User selected item ${it.id} (${it.title}).` }]
          });
        } catch (_) {}
      });

      function moneyToString(m) {
        const amount = (typeof m?.amount === "number") ? m.amount.toFixed(2) : "0.00";
        return `$${amount} ${m?.currency || "USD"}`;
      }

      function showDetails(it) {
        const detail = document.getElementById("detail");
        detail.innerHTML = `
          <div class="card">
            <div class="row">
              <img src="${it.imageUrl}" alt=""/>
              <div style="flex:1">
                <div><b>${it.title}</b></div>
                <div class="muted">${it.brand} ‚Ä¢ ${it.category} ‚Ä¢ ${moneyToString(it.price)}</div>
                <div>
                  ${(it.sizes || []).slice(0,6).map(s => `<span class="pill">${s}</span>`).join("")}
                </div>
              </div>
            </div>
            <div style="display:flex; gap:8px; margin-top:10px;">
              <button id="likeBtn" class="primary">üëç Like</button>
              <button id="dislikeBtn">üëé Dislike</button>
              <button id="openBtn">Open</button>
            </div>
            <div class="muted" style="margin-top:8px;">
              Ratings directly call <code>feedback.rateItem</code>.
            </div>
          </div>
          <div class="card">
            <div><b>Next actions</b></div>
            <div class="muted">In production: try-on, outfit building, add-to-plan, checkout approval.</div>
            <button id="approveBtn" style="margin-top:10px;">Create approval link (demo)</button>
          </div>
        `;

        document.getElementById("openBtn").onclick = () => {
          // ChatGPT extension: openExternal. If not present, just navigate.
          if (window.openai && typeof window.openai.openExternal === "function") {
            window.openai.openExternal(it.retailerUrl);
          } else {
            window.open(it.retailerUrl, "_blank");
          }
        };

        document.getElementById("likeBtn").onclick = async () => {
          await callTool("feedback.rateItem", { itemId: it.id, rating: 1 });
        };
        document.getElementById("dislikeBtn").onclick = async () => {
          await callTool("feedback.rateItem", { itemId: it.id, rating: -1 });
        };

        document.getElementById("approveBtn").onclick = async () => {
          const resp = await callTool("checkout.createApprovalLink", { itemIds: [it.id], notes: "Demo approval" });
          const sc = resp?.structuredContent || resp?.result?.structuredContent;
          if (sc?.url) {
            alert("Approval link created:\n" + sc.url);
          }
        };
      }

      // Upload photo hook (ChatGPT extension)
      document.getElementById("uploadPhotos").addEventListener("click", async () => {
        if (!(window.openai && typeof window.openai.uploadFile === "function")) {
          alert("Photo upload is available in ChatGPT host via window.openai.uploadFile. Not available in this environment.");
          return;
        }
        const input = document.createElement("input");
        input.type = "file";
        input.accept = "image/png,image/jpeg,image/webp";
        input.multiple = true;
        input.onchange = async () => {
          const files = Array.from(input.files || []);
          for (const f of files) {
            const { fileId } = await window.openai.uploadFile(f);
            console.log("Uploaded fileId:", fileId);
          }
          // In production: call profile.ingestPhotos tool with fileIds.
          alert("Uploaded " + files.length + " file(s). In production, call profile.ingestPhotos with fileIds.");
        };
        input.click();
      });

      // Initial load
      refresh().catch(console.error);
    </script>
  </body>
</html>
